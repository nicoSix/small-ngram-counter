tamper-proof hashed data storage pattern collaborator acts data origin hashes file hash submitted transaction blockchain message hash sent data consumers point time data consumers verify file’s integrity comparing hash received file hash blockchain hashes match data changed using blockchain decentralized event log means save occurrence events data related immutably shared distributed ledger described [21] technically implemented similar blockchain hashed data storage trust pattern blockchain-based business processes engines proposed lopez-pintado et al [23] store business process models smart contracts blockchain collaborators access smart contract point verify model’s correctness trust pattern business logic activity encoded smart contract deployed blockchain execution smart contract either triggered responsible collaborator another smart contract decentralized business process engine blockchain technology leveraged implement fully decentralized reputation systems decentralized systems need trust centralized party integrity reputation statements aggregation since blockchain participants access data blockchain used tool connect subprocesses decentralized process tool incentivization correct behavior software connector blockchain technology used interface message flows different organizations key-value store well-suited blockchain data management store dynamically resizable provides value given specific key establish mapping addresses contract-relevant data defined possible ethereum addresses case accounts contract never interacted mapping address default value codomain (the set mapped to) mapping may changed contract values type establish permissioning system contract hard-coded perform special actions response specific users permission may come single user vote many privileges may range setting state variables completely destroying contract exact details permissions privileges must specified creation parties identify third-party actor trust entity given authorization update contract real-world state create contract whose purpose store regularly updated data external world use authorization pattern allow trusted source update state periodically/regularly contract service contracts use data allow input sources vote correct answer provide disincentives voting incorrectly determined eventual consensus create off-chain daemon periodically examines blockchain specific events collates records events single off-chain source off-chain entities read well-formatted digest relevant information define contract stores bloom filter coefficient set off-chain clients may download coefficients calculate bloom filter create contract serves space authorized contracts post announcements announcements viewed contract create bulletin board contract requests data posted answered users define decision process acceptance answers perhaps using vote judge patterns expose answer data define token contract-based cryptocurrency use address mapping pattern associate ethereum address balance provide functions transfer balance users create special migration contract serves pointer current version contract contract upgraded migration contract updated pointer latest version article introduced design pattern – called inter-family communication – provides design solution enable smart contracts communicate one another even case smart contracts written different programming languages prevent reentrancy vulnerabilities provide security plugin (ie design pattern) locking smart contract locking feature eliminates reentrancy vulnerabilities “foolproof” manner functions within contract cannot nested within way provide plugin prevent unpredictable-state vulnerabilities enforcing strict ordering function executions plugin expects transition number every function parameter (ie transition input variable) ensures number incremented one function execution result user invokes function next transition number sequence sure function executed state changes take place (or function executed) implement timed transitions modifier applied every function transition invoked modifier checks whether timed transitions must executed invoked transition executed modifier executes timed transitions invoked transition many contracts access certain transitions (ie functions) needs controlled restricted example user participate typical blind auction submitting bid creator able cancel auction facilitate enforcement constraints provide plugin 1) manages list administrators runtime (identified addresses) 2) enables developers forbid non-administrators accessing certain functions pattern used distribute fungible goods (represented tokens) users tokens represent wide variety goods like eg coins shares outcomes tickets everything else transferable countable pattern used restrict execution code according caller address majority analysed contracts check caller address contract owner performing critical operations (eg sending ether invoking suicide selfdestruct) contracts may need acquire data outside blockchain eg website determine winner bet ethereum language allow contracts query external sites otherwise determinism computations would broken different nodes could receive different results query oracles interface contracts outside dealing randomness trivial task ethereum since contract execution must deterministic nodes must obtain value asking random number struggles randomness requirements wished address issue several contracts (eg slot) query oracles generate values off-chain polls allows users vote question often side feature complex scenario instance dice game certain state reached owner issues poll decide whether emergency withdrawal needed determine vote keep track votes polls use tokens check voters’ addresses many contracts implement time constraints eg specify action permitted instance birthdaygift allows users collect funds redeemable birthday notary contracts time constraints used prove document owned certain date since blockchain immutable contract cannot deleted use come end hence developers must forethink way disable still present unresponsive done manually inserting ad-hoc code contract automatically calling selfdestruct suicide contracts using pattern encode logic guards execution critical operations instance badge implements method named subtractsafely avoid subtracting value balance enough funds account ethereum blockchain forked four times starting july 20th 2016 fork performed contrast effect dao attack [4] know whether fork took place contracts inspect final balance dao contracts use check detect whether running main chain fork performing different actions two cases contract first checks whether necessary conditions met makes necessary changes contract state (effects) finally passes control another contract (interactions) infact anti-pattern low-level solidity function addresscall() used invoke contract instead high-level addresssend() addresstransfer() preferred set limit amount gas1 contract forward invoked contract contract blockchain-based application may sometimes need access information external world oracle pattern uses third-party verifier verify information stored off-chain valid relayed blockchain raw data stored blockchain takes much memory calculate hash entire raw data store blockchain instead micro-transactions stored blockchain; stored off-chain final settled amounts stored on-chain use-cases pattern common lightning network bitcoin plasma ethereum every contract address stored off-chain key-value pairs mapping mutable since off-chain means address contract updated registry since calls contract go registry leaves dependencies intact store data code separate contracts decouple contracts must embedded permission field certain critical functions allows authorized users run comparable end-user access back-end code pattern similar idea class programming languages entails storing template contract blockchain instantiate contracts similar structure flow include ability authorized party stop execution contract patern similar mutexes traditional programming prevents contract executing code parent contract parent executed completely pattern states contract hold funds predefined balance-limit must reject transactions made except forced payments sometimes application may need access data blockchain like oracle pattern reverse verifier used verify data sent external source blockchain make seldom-run utility functions piggyback onto contracts execute often pattern works hiding certain secret variables contract’s function displaying final values authorized users may access secret create proxy contract accept forward parameters current version contract create dynamic association contract authorized users’ addresses way addresses defined contract instead users send secret key another designated contract forwards request main one key valid inspired part data contract design pattern flyweight contract stores data shared group clients one common place store static variables smart contracts smallest possible data type fit example don’t store value int could stored byte introducing state external systems closed blockchain execution environment off-chain components existing system rely smart contracts running blockchain supply requested data check required conditions bidirectional binding established legal agreement corresponding smart contract ensure confidentiality data stored blockchain encrypting using tokens blockchain represent transferable digital physical assets services use hashing ensure integrity arbitrarily large datasets may fit directly blockchain transactions small value relative blockchain transaction fee require much shorter latency provided blockchain performed off-chain periodic recording net transaction settlements onchain set blockchain addresses authorise transaction predefined subset addresses required authorize transactions using hash created off-chain dynamically bind authority transaction waiting enough number blocks confirmations ensure transaction added blockchain immutable high probability invoking smart contract address latest version smart contract located looking name contract registry smart contracts use embedded permission control restrict access invocation functions defined smart contracts store data separate smart contract on-chain template contract used factory generates contract instances template reward provided caller contract function invoking entity master-key managing sub-keys used signing transactions different identity accounts entity maintain hot wallet connecting internet cold wallet kept offline key split several different pieces restored using enough key pieces identifier registry maintains bindings identifier address identity attribute entity register unique identifier relationship bidirectional binding established social media profile blockchain-based identity establish interactions two entities mutually acquire other’s ddo verification communication information identifier maintains list delegates help user recover identity issuer generates customised credential according holders specific requirements credential contents holder share link redirected credential content specified period time holder share one-off link redirected credential content one time satisfy temporary identification request periodically sending unique hash value off-chain data blockchain get snapshot states smart contracts transactions source blockchain aggregate set states single (or few) state make states smart contracts source blockchain unusable migration create clone blockchain node synchronizing blocks history set state target blockchain’s genesis block change global state target blockchain initialize/recreate states target blockchain transfer states via exchange replay transactions target blockchain recreate states history allow smart contracts written one language run another blockchain platform translate smart contract code one language another solution based incorporation blockchain layer uses nodes utilized big data ecosystems layer act distributed ledger system registers operations performed data stored use proxy delegate pattern proxy patterns set scs working together facilitate upgrading scs despite intrinsic immutability proxy holds addresses referred scs state variables changed way references new sc must updated keep data separate sc accessed one sc using data holding processing logic logic must updated data remain data contract pattern usually included also implementations proxy pattern past events data needed external system scs let external system directly access event log blockchain note log accessible scs event happened far time time retrieve may long limit data stored blockchain always use memory non-permanent data also limit changes storage executing functions save intermediate results memory stack update storage end computations pack variables declaring storage variables packable ones data type declared consecutively way packing done automatically solidity compiler (note pattern work memory calldata memories whose variables cannot packed) pack booleans single uint256 variable purpose create functions pack unpack booleans single variable cost running functions cheaper cost extra storage use unsigned integers smaller equal 128 bits packing variables one slot (see variables packing pattern) better use uint256 variables order save gas recommended use mappings manage lists data unless need iterate possible pack data types useful storage memory manage ordered list mapping using integer index key whenever possible set upper bound size array use fixed size array instead dynamic one solidity variables set zeroes default explicitly initialize variable default value zero minimize on-chain data less data put on-chain storage variables less gas costs store on-chain critical data sc keep possible data off-chain input parameters external functions read right calldata memory therefore explicitly mark external functions called externally limit external calls solidity differently programming languages better call single multi-purpose function many parameters get back requested results rather making different calls data whenever possible prefer internal function calls parameters passed references general keep mind implementing sc many small functions expensive however big functions complicates testing potentially compromises security try fewer functions balancing function number complexity use libraries bytecode external libraries part sc thus saving gas however calling costly security issues use libraries balanced way complex tasks using logical operators order expressions reduce probability evaluating second expression remember logical disjunction (or ||) first expression resolves true second one executed; logical disjunction (and &&) first expression evaluated false next one evaluated keep constant strings short sure constant strings fit 32 bytes example possible clarify error using string; messages however included bytecode must kept short avoid wasting memory limit modifiers internal functions inlined called separate functions slightly expensive run time save lot redundant bytecode deployment used avoid redundant operations instance avoid double checks; use safemath library prevents underflow overflow need check solidity allows swap values two variables one instruction instead classical swap using auxiliary variable use (a b) = (b a) write values instead computing already know value data compile time write directly values use solidity functions derive value data initialization might lead less clear code saves gas help keeping size blockchain smaller get gas refund every time free storage therefore convenient delete variables storage using keyword delete soon longer necessary always turn solidity optimizer option solidity compilers performs optimizations made compiler however substitute usage presented patterns need information available compiler paper aims propose pattern allows execution automatable legal contract clauses execution states stored on-chain smart-contract logic needed enforce wraps off-chain engine completes pattern running business process corresponds legal contract directly interacting edcc (executable distributed code contract) necessary interface description (application binary interface abi) edcc publicly available furthermore understanding specific actions carried contract source code published well dapps structured pattern security advantage users keep private keys device able generate sign send transactions transactions generated user triggered dapp website presented user verification manually sent blockchain node thus pattern offers trade-off convenience trust required dapp website providing transaction details dapp provider offers website users interact requiring cryptobrowser metamask plugin website communicates dapp backend logic via rest calls encapsulates blockchain-specific actions means backend responsible interacting blockchain sending transactions behalf user able validate “mirror” system blockchain serves repository “digital fingerprints” hashes records original records may born paper digital exist digital form hashed produces sort digital fingerprint record hashes anchored blockchain blockchain used mirror records reflecting back hashes records longer mirrored chain actively created chain form “smart contracts” marks fundamental departure traditional form digital records creation storage centralized databases cloud-based platforms typically smart contracts encode procedures execute among multi-stakeholder network part work process flow “digital records” systems execution smart code results update distributed database records ledger implementing state change smart contract completed type system records captured chain assets represented captured chain assets represent anything value – currency original use case blockchain – bitcoin - land fine wine food diamonds artworks etc readers may ask whether assets records problem contract sends funds another party send operation fail solution let receiver payment withdraw funds problem application scenario implicates different behavioural stages transitions solution apply state machine model represent different behavioural contract stages transitions apply commitment scheme ensure value submission binding concealed consolidation phase runs value revealed publicly verifiable value remained unchanged request external data oracle service connected outside world acts data carrier store contract creator’s address owner contract restrict method execution dependent callers address define generally applicable modifiers check desired requirements apply modifiers function definition use selfdestruct call within method preliminary authorization check invoking party define expiration time apply modifiers function definitions disable function execution expiration date reached decouple data operational logic separate contracts outsource functional units likely change separate so-called satellite contracts use reference contracts order utilize needed functionality let contract participants pro-actively query latest contract address register contract returns address recent version contract participants always interact proxy contract relays requests recent contract version product separate blockchain set respective supply chain organizations product data stored blockchain shared participating organizations competitor access data data blockchain-based system symmetrically encrypted on-chain single permissioned blockchain preserve data privacy every event asset encrypted separate cryptographic key stored off-chain distributed decentralized database organizations part supply chain product organizations access keys therefore de- encrypt corresponding data blockchain connects members different supply chains product distributed decentralized off-chain database created con- tains relevant product information data point linked blockchain it’s hash value ensures organizations possession data confirm tampered send operation fail let receiver withdraw payment different contract stages needed modeled represented state machine blockchain data public commitment scheme ensures confidentiality contract interactions knowledge outside blockchain required oracle pushes information network anyone call contract method restrict execution contract owner’s address function execution checkups needed handled generally applicable modifiers since deployed contracts expire self-destruction preliminary authorization check used functions shall become deprecated apply function modifiers disable future execution data logic usually reside contract avoid data migration updates decoupling contracts immutable functions likely change outsourced separate contracts latest contract version unknown participants pro-actively query register latest contract version unknown participants interact proxy contract calls contracts hand control avoid security issues functional code order since contracts executed autonomously sensitive functions include halt case bugs task execution huge number users unwanted prolong completion counter measures request rush task desired regulate often task executed within period re-entrancy attacks manipulate contract state mutex hinders external calls re-entering always risk contract gets compromised thus limit maximum amount funds held address issues blockchain storage capability limitation data privacy on-chain off-chain service proposed store critical data required im- mutable on-chain keep data off-chain enhance data reading efficiency preserve privacy involved participants pro- vide data encryption service encrypts on-chain data ensure confidentiality data stored blockchain users first encrypt data item using secret key store blockchain blockchain participants secret key allowed access transaction decrypt information hash integrity service focuses use blockchain ensure integrity large amounts data hashing applied guarantee integrity arbitrarily large datasets may fit directly blockchain service stores hash raw data blockchain achieve data integrity raw data participants blockchain network lack trust integrity raw data checked using on-chain hash value multiple authorities service focuses activities blockchain-based applications (ie transactions) need authorised multiple blockchain addresses users predefine group blockchain addresses authorise transaction (ie calling function smart contract) set minimal number authorisations transaction approval blockchain applications activities need approved one participants unknown first transaction submitted blockchain authority authorise given activity unknown correspond- ing smart contract deployed corresponding trans- action submitted blockchain dynamic binding service supports dynamic association address participant defined respective transaction smart contract smart contracts running blockchain accessed called participants smart contracts default smart contract default owner means author smart contract special privilege smart contract smart contract deployed performing function sc first check preconditions apply effects contract's state finally interact contracts never alter sequence proxy patterns set scs working together facilitate upgrading scs despite intrinsic immutability proxy used refer another sc whose address changed approach also ensures blockchain resources used sparingly thus saving gas restrict execution critical methods specific users accomplished using mappings addresses typically checked using modifiers specify contract owner responsible contract management special permissions eg address authorized call critical methods patter seen special instance authorization pattern oracle sc providing data outside blockchain turn fed oracle trusted source security risk lies actually source trusted reverse oracle sc providing data read off-chain components checking specific conditions regulate often task executed within period time limit number messages sent sc thus computational load limit maximum amount funds held within sc ensure requirements sc state function inputs met time constraint specifies action permitted depending time registered block holding transaction could also used speed bump rate limit patterns used life sc come end done inserting ad-hoc code contract calling selfdestruct function usually contract owner authorized terminate contract logic computes critical operations protecting overflows underflows undesired characteristics finite arithmetic encrypt on-chain critical data improving confidentiality meeting legal requirements european gdpr use contract libraries templates factory creating multiple instances mutex mechanism restrict concurrent access resource utilize hinder external call re-entering caller function slow contract sensitive tasks malicious actions occur damage limited time counteract available instance limit amount money user withdraw per day impose delay withdrawals state change must trigger computation different object implement messaging infrastructure contracts produce messages (called publishers) generate messages contracts (called subscribers) receive pattern also known observer reduces overhead constant information filtering use tokens transferring digital physical services use standards erc20 erc721 order ensure transaction confirmed (ie low probability fork happens) wait new blocks added blockchain amount blocks depends adopted blockchain often smart contract needs interact contracts updated time contract registry maps smart contract address latest version accordingly invoking smart contract correct address retrieved registry contract data logic stored separate contracts way logic need updated (by using new smart contract) need migrate old data sometimes systems need work groups related contracts instance contracts represent various level user account order keep system independent different contracts define abstract contract creating related contracts abstract factory pattern facilitate scenario factory object (the factory contract instance) responsible providing creation services concrete departmental contracts entire health organization factory object create contracts group departments subdivisions related always interact easy instantiate another factory object new interactions take place order achieve blockchain’s transparency immutability properties data transaction records maintained blockchain replicating distributing every node network important limit amount data stored blockchain avoid high cost data storage unattended data longer needed proxy pattern well-known software pattern applied blockchain-based data storage resolve tension created public immutable aspects blockchain using proxy pattern blockchain proxy contract created provide lightweight representation placeholder data intensive computation (such acquiring data off-blockchain storage via oracle proxy contract expose simpler metadata patient later refer heavyweight implementation demand obtain real data object read request modification operation data store logged audit trail transparent entire blockchain network verification data corruption proxified contract (with heavyweight implementation) updated new storage option instance interface proxy contract remain encapsulating detailed implementation variations publisher-subscriber pattern assist broadcasting information care providers subscribe events relating patient solves issue constant information filtering actively monitoring patient activities sending notifications patient’s care team activities take place avoid computation overhead blockchain actual processing patient activities data done off-chain back-end server receiving events interest subscribers pass heavy computation tasks server follow recommended functional code order calls external contracts always last step reduce attack surface contract manipulated externally called contracts incorporate emergency stop functionality contract triggered authenticated party disable sensitive functions prolong completion sensitive tasks take steps fraudulent activities regulate often task executed within period time utilize mutex hinder external call re-entering caller function limit maximum amount funds risk held within contract instead checking whether state final smart contract blockchain check performed off-chain client side client notify smart contract final state reached clients prove claims wrong providing valid state transition using pattern computation never performed on-chain together two participants specify smart contract including function applies external state given argument contract state function includes signature check ensure participants agree state change valid signatures participants supplied requested new state new state applied contract deployed blockchain participants optionally make deposit participants perform transactions purely off-chain peer-topeer without involving blockchain one participant computes new state wraps transaction signs sends counterpart recipient checks new state signs transaction well case agrees sends back sender transaction signed parties sent smart contract participant point time validating signatures contract updates state accordingly store data off-chain content-addressable storage system store reference smart contract clients using smart contract retrieve reference based retrieve data verify data’s correctness recomputing address comparing reference stored smart contract outsource computation untrusted third party besides result generate proof correct execution instead executing computation verify proof correct execution on-chain optimize fees contracts designed way minimizes number size on-chain transactions following two techniques used reduce footprint – check conditions on-chain state change let nodes perform condition check locally trigger on-chain check case success – optimize writes reads reading smart contracts local off-chain operation require on-chain transaction minimize writes store information free redundancy compute derived data locally reads pattern allows dapps like dash delegate responsibility providing account creation services abstract factory object (which contract instance itself) concrete factory object inherit methods abstract factory customize create accounts specific set related interacting sub-entities combining flyweight pattern factory object help minimize data storage blockchain particular factory establish registry model stores shared data set entities common contract ie registry externalizing var- ying data stored entity-specific contracts registry also maintain references (ie addresses) entity-specific contracts return combined extrinsic intrinsic (common) data set upon request combining proxy pattern secure data retrieving service oracle enable secure private data exchange services oracle network third-party service allows smart contract query retrieve data sources outside blockchain address space ensures retrieved data genuine uncompromised reduce computation overhead on-chain proxy created lightweight representation placeholder real data retrieval required incorporating notification service using publisher-subscriber pattern facilitate scalable information filtering design health activities broadcast providers subscribe events relating patients alleviates tedious filtering process determining care provider notified patient activities large volumes transactions take place pull-based inbound oracle allows blockchain applications request states off-chain components blockchain application requests off-chain state pull-based inbound oracle receives request gathers state off-chain components sends result back blockchain (via transaction) push-based inbound oracle allows off-chain information propagated blockchain monitoring off-chain state changes forwarding blockchain pull-based outbound oracle allows blockchain data queried filtered make available outside world called (off-chain) components pull (all) blockchain data query relevant information push-based outbound oracle monitors blockchain relevant changes subsequently trigger perform activities outside blockchain compiled code smart contract deployed blockchain readable tedious deploy manage smart contracts properties aim diverse clients help pattern developers need deploy smart contracts one another deploy contract factory required multiple instances instantiated blockchain-based application combination services objects inevitable consequently effectively control combination becomes challenge developers especially condition service object represented form smart contract compared contract factory contract composer focuses complex structure contract instance construct complicated target multiple small pieces smart contract deployed blockchain allowed modify update source code contract contract decorator pattern avoid rewriting whole contract new requirements developers need encapsulate old contracts append required features new version contract pattern achieve updatability modifiability managing smart contracts may burdensome work massive contracts similar features blockchain-based system contract facade pattern relieve pressure via providing simple interface coping contract addresses interface also form smart contract developers call functions similar contracts business process smart contracts need interact finish certain activity may result tight coupling contracts contract mediator pattern aims reduce communication complexity smart contracts instance pattern form smart contract collects encapsulates interactions invocations one contract others decoupling smart contracts smart contract modified due changing requirements industry related contracts need informed updated automatically contract observer pattern deal problem achieve interoperability updatability among contracts via observer instance instance contract observer needs define objects information involved changes notify objects update information pattern help user achieve authorisation particular activity unknown authorities generating digital secret key known hash secret authority decided receive hash secret thus ability finish task multiple authorities blockchain network pattern provide flexible way achieve better cooperation transaction valid enough signatures authorities addition pattern also considered individual safeguard mechanism current blockchain technology provide way recover lost private key