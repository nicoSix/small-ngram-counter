In the tamper-proof hashed data storage pattern, the collaborator who acts as the data origin hashes the file. The hash is submitted through a transaction to the blockchain. A message with the hash is sent to data consumers. At any point in time, data consumers can verify the file’s integrity by comparing the hash of the received file with the hash on the blockchain. If the hashes do not match up, data has been changed.
Using the blockchain as a decentralized event log means to save the occurrence of events and data related to them immutably on a shared distributed ledger, as described in [21]. Technically, this can be implemented similar to the blockchain hashed data storage trust pattern. 
Blockchain-based business processes engines, as proposed by Lopez-Pintado et al. [23], store business process models in smart contracts on a blockchain. All collaborators have access to the smart contract and can, at any point, verify the model’s correctness.
In this trust pattern, the business logic of an activity is encoded in a smart contract and deployed on the blockchain. The execution of the smart contract is either triggered by the responsible collaborator or by another smart contract, such as a decentralized business process engine.
The blockchain technology can be leveraged to implement fully decentralized reputation systems. In such decentralized systems, there is no need to trust a centralized party for the integrity of reputation statements and their aggregation since all blockchain participants have access to the data
Blockchain can be used as a tool to connect subprocesses in a decentralized process and as a tool for incentivization of correct behavior. As a software connector, the blockchain technology can be used as an interface for message flows between different organizations.
A key-value store is well-suited to blockchain data management, where the store is dynamically resizable and provides a value given a specific key.
Establish a mapping from addresses to contract-relevant data, defined for all possible Ethereum addresses. In the case of accounts that the contract has never interacted with, the mapping is from the address to a default value of the codomain (the set being mapped to). This mapping may be changed by the contract to other values of the type.
Establish a permissioning system where the contract is hard-coded to perform special actions in response to specific users. This permission may come from a single user or a vote of many, and privileges may range from setting state variables to completely destroying the contract. The exact details of the permissions and privileges must be specified at creation.
All parties identify a third-party actor that they all trust. This entity is given Authorization to update the contract with real-world state.
Create a contract whose only purpose is to store regularly updated data about the external world. Use the Authorization pattern to allow a trusted source to update the state periodically/regularly. This contract is a service to other contracts that use the data.
Allow the input sources to vote on the correct answer. And, provide disincentives for voting incorrectly, as determined by the eventual consensus.
Create an off-chain daemon that periodically examines the blockchain for specific events and collates the records of those events into a single off-chain source. Off-chain entities can then read a well-formatted digest of the relevant information.
Define a contract that stores a Bloom filter coefficient set. Off-chain clients may download the coefficients to calculate with the Bloom filter
Create a contract that serves as a space where Authorized contracts can post announcements. These announcements can then be viewed by any other contract.
Create a Bulletin Board contract, where requests for data can be posted and answered by users. Define a decision process for acceptance of the answers, perhaps using the Vote or Judge patterns, and expose the answer data.
Define a token, or contract-based cryptocurrency. Use the Address Mapping pattern to associate each Ethereum address with a balance and provide functions for transfer of balance between users.
Create a special Migration contract that serves as a pointer to the current version of the contract. When the contract is upgraded, the Migration contract is updated with a pointer to the latest version.
In this article, we have introduced a design pattern – called Inter-Family Communication – that provides a design solution to enable smart contracts to communicate with one another, even in the case where the smart contracts are written in different programming languages. 
To prevent reentrancy vulnerabilities, we provide a security plugin (ie. design pattern) for locking the smart contract. The locking feature eliminates reentrancy vulnerabilities in a “foolproof” manner: functions within the contract cannot be nested within each other in any way.
We provide a plugin that can prevent unpredictable-state vulnerabilities by enforcing a strict ordering on function executions. The plugin expects a transition number in every function as a parameter (i.e., as a transition input variable) and ensures that the number is incremented by one for each function execution. As a result, when a user invokes a function with the next transition number in sequence, she can be sure that the function is executed before any other state changes can take place (or that the function is not executed).
We implement timed transitions as a modifier that is applied to every function. When a transition is invoked, the modifier checks whether any timed transitions must be executed before the invoked transition is executed. If so, the modifier executes the timed transitions before the invoked transition. 
In many contracts, access to certain transitions (i.e., functions) needs to be controlled and restricted. For example, any user can participate in a typical blind auction by submitting a bid, but only the creator should be able to cancel the auction. To facilitate the enforcement of such constraints, we provide a plugin that 1) manages a list of administrators at runtime (identified by their addresses) and 2) enables developers to forbid non-administrators from accessing certain functions. 
This pattern is used to distribute some fungible goods (represented by tokens) to users. Tokens can represent a wide variety of goods, like e.g. coins, shares, outcomes or tickets, or everything else which is transferable and countable.
This pattern is used to restrict the execution of code according to the caller address. The majority of the analysed contracts check if the caller address is that of the contract owner, before performing critical operations (e.g., sending ether, invoking suicide or selfdestruct).
Some contracts may need to acquire data from outside the blockchain, e.g. from a website, to determine the winner of a bet. The Ethereum language does not allow contracts to query external sites: otherwise, the determinism of computations would be broken, as different nodes could receive different results for the same query. Oracles are the interface between contracts and the outside.
Dealing with randomness is not a trivial task in Ethereum. Since contract execution must be deterministic, all the nodes must obtain the same value when asking for a random number: this struggles with the randomness requirements wished. To address this issue, several contracts (e.g., Slot) query oracles that generate these values off-chain.
Polls allows users to vote on some question. Often this is a side feature in a more complex scenario. For instance, in the Dice game, when a certain state is reached, the owner issues a poll to decide whether an emergency withdrawal is needed. To determine who can vote and to keep track of the votes, polls can use tokens, or they can check the voters’ addresses.
Many contracts implement time constraints, e.g. to specify when an action is permitted. For instance, BirthdayGift allows users to collect funds, which will be redeemable only after their birthday. In notary contracts, time constraints are used to prove that a document is owned from a certain date.
Since the blockchain is immutable, a contract cannot be deleted when its use has come to an end. Hence, developers must forethink a way to disable it, so that it is still present but unresponsive. This can be done manually, by inserting ad-hoc code in the contract, or automatically, calling selfdestruct or suicide.
Contracts using this pattern encode the logic which guards the execution of some critical operations. For instance, Badge implements a method named subtractSafely to avoid subtracting a value from a balance when there are not enough funds in an account
The Ethereum blockchain has been forked four times, starting from July 20th, 2016, when a fork was performed to contrast the effect of the DAO attack [4]. To know whether or not the fork took place, some contracts inspect the final balance of the DAO. Other contracts use this check to detect whether they are running on the main chain or on the fork, performing different actions in the two cases.
The contract first checks whether the necessary conditions are met, then makes necessary changes to the contract state (effects) and finally passes control to another contract (interactions)
This is infact an anti-pattern. The low-level Solidity function, address.call() should not be used to invoke a contract. Instead, the high-level address.send() or address.transfer() should be preferred because they set a limit on the amount of gas1 the contract can forward to any invoked contract.
A contract or blockchain-based application may sometimes need to access information from the external world. The oracle pattern uses a third-party verifier to verify that information stored off-chain is valid, before it can be relayed to the blockchain.
If the raw data to be stored on the blockchain takes too much memory, calculate a hash for the entire raw data and store this on the blockchain instead.
Micro-transactions should not be stored on the blockchain; they should be stored off-chain and only the final settled amounts should be stored on-chain. There are some use-cases of this pattern, the most common being the Lightning Network in Bitcoin and Plasma in Ethereum.
Every contract and its address are stored off-chain as key-value pairs. This mapping is mutable since it is off-chain, which means that the address of a contract can be updated in the registry. Since calls to any contract will now go through the registry, this leaves all dependencies intact. 
Store data and code on separate contracts to decouple them.
Contracts must have an embedded permission field for certain critical functions, which allows only authorized users to run them. This is comparable to an end-user not having access to all the back-end code.
This pattern is similar to the idea of a class in programming languages. It entails storing a template contract on the blockchain to instantiate other contracts having a similar structure and flow
Include the ability for an authorized party to stop the execution of a contract.
This patern is similar to mutexes in traditional programming. It prevents a contract from executing code in its parent contract, until the parent has executed completely. 
This pattern states that a contract should not hold any more funds than a predefined balance-limit. It must reject any further transactions made to it except for forced payments.
Sometimes an application may need to access data from the blockchain. Like the oracle pattern, reverse verifier is used to verify data being sent to an external source from the blockchain.
Make seldom-run utility functions piggyback onto contracts that execute more often.
This pattern works by hiding certain secret variables in a contract’s function, and only displaying the final values. Authorized users may have access to the secret.
Create a proxy for each contract, which will accept, and then forward the parameters to the current version of the contract.
Create a dynamic association between a contract and its authorized users’ addresses, in such a way that the addresses are not defined in the contract. Instead, the users send a secret key to another, designated contract, which forwards the request to the the main one if the key is valid.
Inspired in part by the data contract design pattern, the flyweight contract stores data that is shared by a group of clients in one common place.
Store static variables in smart contracts as the smallest possible data type that they can fit in. For example don’t store a value as an int if it could be stored as a byte.
Introducing the state of external systems into the closed blockchain execution environment.
The off-chain components of an existing system rely on smart contracts running on a blockchain to supply requested data and check required conditions.
A bidirectional binding is established between a legal agreement and a corresponding smart contract.
Ensure confidentiality of the data stored on blockchain by encrypting it.
Using tokens on blockchain to represent transferable digital or physical assets or services.
Use hashing to ensure the integrity of arbitrarily large datasets which may not fit directly on the blockchain.
Transactions that are too small in value relative to a blockchain transaction fee or that require much shorter latency than can be provided by a blockchain, are performed off-chain with periodic recording of net transaction settlements onchain.
A set of blockchain addresses which can authorise a transaction is predefined. Only a subset of the addresses is required to authorize transactions.
Using a hash created off-chain to dynamically bind authority for a transaction.
Waiting for enough number of blocks as confirmations to ensure that a transaction added into blockchain is immutable with high probability
Before invoking a smart contract, the address of the latest version of the smart contract is located by looking up its name on a contract registry
Smart contracts use embedded permission control to restrict access to the invocation of the functions defined in the smart contracts
Store data in a separate smart contract.
An on-chain template contract is used as a factory that generates contract instances from the template.
A reward is provided to the caller of a contract function for invoking it.
Each entity has a master-key for managing sub-keys which are used for signing transactions for different identity accounts.
An entity can maintain a hot wallet connecting to internet and a cold wallet which is kept offline.
A key can be split up into several different pieces, and restored using enough key pieces.
The identifier registry maintains bindings between an identifier and the address of an identity attribute
Each entity can register a unique identifier for each relationship.
A bidirectional binding is established between social media profile and blockchain-based identity
To establish interactions, two entities can mutually acquire each other’s DDO for verification and communication information.
Each identifier maintains a list of delegates that can help the user recover the identity
An issuer generates a customised credential according to a holders specific requirements about credential contents.
A holder can share a link which is redirected to the credential content only for a specified period of time.
A holder can share a one-off link which is redirected to the credential content one time only to satisfy a temporary identification request.
Periodically sending the unique hash value of off-chain data to blockchain.
Get a snapshot of states, smart contracts, and transactions on the source blockchain.
Aggregate a set of states into a single (or a few) state.
Make states and smart contracts on the source blockchain unusable before the migration.
Create a clone of a blockchain node by synchronizing blocks and history.
Set the state on the target blockchain’s genesis block.
Change the global state of the target blockchain.
Initialize/recreate states on the target blockchain.
Transfer states via an exchange.
Replay transactions on the target blockchain to recreate both states and history.
Allow smart contracts written in one language to run on another blockchain platform.
Translate smart contract code from one language to another.
The solution is based on the incorporation of a Blockchain layer that uses the same nodes utilized by the Big Data ecosystems. This layer will act as distributed ledger system that registers all the operations performed over the data stored.
Use Proxy delegate pattern. Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy holds the addresses of referred SCs, in its state variables, which can be changed. In this way, only the references to the new SC must be updated.
Keep the data in a separate SC, accessed by one or more SC, using the data and holding the processing logic. If this logic must be updated, the data remain in the Data Contract. This pattern usually is included also in the implementations of the Proxy pattern.
If past events data are needed by the external system, but not by SCs, let the external system directly access the Event Log in the blockchain. Note that this Log is not accessible by SCs, and that if the event happened far in time, the time to retrieve it may be long.
Limit data stored in the blockchain, always use memory for non-permanent data. Also, limit changes in storage: when executing functions, save the intermediate results in memory or stack and update the storage only at the end of all computations.
Pack the variables. When declaring storage variables, the packable ones, with the same data type, should be declared consecutively. In this way, the packing is done automatically by the Solidity compiler. (Note that this pattern does not work for Memory and Calldata memories, whose variables cannot be packed.)
Pack Booleans in a single uint256 variable. To this purpose, create functions that pack and unpack the Booleans into and from a single variable. The cost of running these functions is cheaper than the cost of extra Storage.
Use unsigned integers smaller or equal than 128 bits when packing more variables in one slot (see Variables Packing pattern). If not, it is better to use uint256 variables.
In order to save gas, it is recommended to use mappings to manage lists of data, unless there is a need to iterate or it is possible to pack data types. This is useful both for Storage and Memory. You can manage an ordered list with a mapping using an integer index as a key.
Whenever it is possible to set an upper bound on the size of an array, use a fixed size array instead of a dynamic one.
In Solidity, all variables are set to zeroes by default. So, do not explicitly initialize a variable with its default value if it is zero.
Minimize on-chain data. The less data you put on-chain in Storage variables, the less your gas costs. Store on-chain only critical data for the SC and keep all possible data off-chain.
The input parameters of external functions are read right from Calldata memory. Therefore, explicitly mark as external functions called only externally.
Limit external calls. In Solidity, differently from other programming languages, it is better to call a single, multi-purpose function with many parameters and get back the requested results, rather than making different calls for each data.
Whenever possible, prefer internal function calls, where the parameters are passed as references.
In general, keep in mind that implementing a SC with many small functions is expensive. However, having too big functions complicates the testing and potentially compromises the security. So, try to have fewer functions, but not too few, balancing the function number with their complexity.
Use libraries. The bytecode of external libraries is not part of your SC, thus saving gas. However, calling them is costly and has security issues. Use libraries in a balanced way, for complex tasks.
When using the logical operators, order the expressions to reduce the probability of evaluating the second expression. Remember that in the logical disjunction (OR, ||), if the first expression resolves to true, the second one will not be executed; or that in the logical disjunction (AND, &&), if the first expression is evaluated as false, the next one will not be evaluated.
Keep constant strings short. Be sure that constant strings fit 32 bytes. For example, it is possible to clarify an error using a string; these messages, however, are included in the bytecode, so they must be kept short to avoid wasting memory.
Limit the modifiers. Internal functions are not inlined, but called as separate functions. They are slightly more expensive at run time, but save a lot of redundant bytecode in deployment, if used more than once.
Avoid redundant operations. For instance, avoid double checks; the use of SafeMath library prevents underflow and overflow, so there is no need to check for them.
Solidity allows to swap the values of two variables in one instruction. So, instead of the classical swap using an auxiliary variable, use: (a, b) = (b, a)
Write values instead of computing them. If you already know the value of some data at compile time, write directly these values. Do not use Solidity functions to derive the value of the data during their initialization. Doing so, might lead to a less clear code, but it saves gas.
To help keeping the size of the blockchain smaller, you get a gas refund every time you free the Storage. Therefore, it is convenient to delete the variables on the Storage, using the keyword delete, as soon as they are no longer necessary.
Always turn on the Solidity Optimizer. It is an option of all Solidity compilers, which performs all the optimizations that can be made by the compiler. However, it does not substitute the usage of the presented patterns, most of which need information that is not available to the compiler.
This paper aims to propose a pattern that allows the execution of automatable legal contract clauses, where its execution states are stored in an on-chain smart-contract and the logic needed to enforce it wraps it off-chain. An engine completes this pattern by running a business process that corresponds to the legal contract.
"For directly interacting with an EDCC (Executable Distributed Code Contract) it is necessary
that the interface description (Application Binary Interface, ABI) of the EDCC is publicly available. Furthermore, for understanding the specific actions carried out by a contract, the source code should be published as well. DApps structured with this pattern have the security advantage that the users keep their private keys on their device and are able to generate, sign and send transactions on their own."
Transactions are not generated by the user but are triggered by the DApp website, presented to the user for further verification and then manually sent to the blockchain node. Thus, this pattern offers a trade-off between convenience and trust that is required in the DApp website providing the transaction details.
DApp provider offers a website the users can interact with, not requiring a cryptobrowser or MetaMask plugin. The website communicates with the DApp backend logic via REST calls and encapsulates all blockchain-specific actions. This means the backend is responsible for interacting with the blockchain and is sending transactions on behalf of the user, who is not able to validate them.
The “mirror” system, the blockchain serves as a repository of “digital fingerprints”, or hashes, of the records. The original records, which may be born paper or digital, but now exist in digital form, are hashed. This produces a sort of digital fingerprint of the record. These hashes are anchored into the blockchain, with the blockchain being used as a mirror of the records, reflecting back their hashes.
"Records are no longer just mirrored on chain, they are actively created on chain in the form of “smart contracts”. This marks a more fundamental departure from the traditional form of digital records creation and storage in centralized databases or cloud-based platforms. Typically, these smart contracts encode procedures that execute among a multi-stakeholder network as part of a work process flow. In these “digital records” systems, execution of the smart code results in an update to the distributed database of records, or ledger, implementing state change once the smart contract has completed.
The"
With this type of system, not only are records captured on chain, but assets are represented and captured on chain. These assets can represent anything of value – currency, as in the original use case for the blockchain – Bitcoin - land, fine wine, food, diamonds, artworks, etc. Readers may ask whether these assets are records. 
Problem When a contract sends funds to another party, the send operation can fail. Solution Let the receiver of a payment withdraw the funds.
Problem An application scenario implicates different behavioural stages and transitions. Solution Apply a state machine to model and represent different behavioural contract stages and their transitions.
Apply a commitment scheme to ensure that a value submission is binding and concealed until a consolidation phase runs out, after which the value is revealed, and it is publicly verifiable that the value remained unchanged.
Request external data through an oracle service that is connected to the outside world and acts as a data carrier.
Store the contract creator’s address as owner of a contract and restrict method execution dependent on the callers address.
Define generally applicable modifiers that check the desired requirements and apply these modifiers in the function definition.
Use a selfdestruct call within a method that does a preliminary authorization check of the invoking party.
Define an expiration time and apply modifiers in function definitions to disable function execution if the expiration date has been reached.
Decouple the data from the operational logic into separate contracts.
Outsource functional units that are likely to change into separate so-called satellite contracts and use a reference to these contracts in order to utilize needed functionality
Let contract participants pro-actively query the latest contract address through a register contract that returns the address of the most recent version.
Contract participants always interact with the same proxy contract that relays all requests to the most recent contract version.
For each product a separate Blockchain is set up between the respective supply chain organizations. All product data is stored in the Blockchain and shared between the participating organizations. No competitor can access any data by himself.
All data in the Blockchain-based system is symmetrically encrypted on-chain on a single permissioned Blockchain to preserve data privacy. Every event or asset is encrypted with a separate cryptographic key, which is stored off-chain in a distributed and decentralized database with all organizations that are part of the supply chain of a product. Only these organizations have access to the keys and therefore can de- or encrypt the corresponding data. 
A Blockchain connects all members of different supply chains. For each product a distributed and decentralized off-chain database is created which con- tains all relevant product information. Each data point is linked in the Blockchain with it’s hash value. This ensures that the organizations in possession of the data can confirm that it is not tampered. 
As a send operation can fail, let the receiver withdraw the payment.
When different contract stages are needed, these are modeled and represented by a state machine.
As blockchain data is public, a commitment scheme ensures confidentiality of contract interactions.
When knowledge outside the blockchain is required, an oracle pushes information into the network.
As anyone can call a contract method, restrict the execution to the contract owner’s address.
When function execution checkups are needed, these are handled by generally applicable modifiers
Since deployed contracts do not expire, self-destruction with a preliminary authorization check is used.
When functions shall become deprecated, apply function modifiers to disable their future execution.
As data and logic usually reside in the same contract, avoid data migration on updates by decoupling.
As contracts are immutable, functions that are likely to change are outsourced into separate contracts.
When the latest contract version is unknown, participants pro-actively query a register.
When the latest contract version is unknown, participants interact with a proxy contract.
As calls to other contracts hand over control, avoid security issues by a functional code order.
Since contracts are executed autonomously, sensitive functions include a halt in the case of bugs.
When task execution by a huge number of users is unwanted, prolong completion for counter measures.
When a request rush on a task is not desired, regulate how often a task can be executed within a period.
As re-entrancy attacks can manipulate contract state, a mutex hinders external calls from re-entering.
There is always a risk that a contract gets compromised, thus limit the maximum amount of funds held.
To address the issues of blockchain storage capability limitation and data privacy, an on-chain and off-chain service is proposed to store the critical data which is required to be im- mutable on-chain while keep all the data off-chain to enhance the data reading efficiency.
To preserve the privacy of the involved participants, we pro- vide a data encryption service that encrypts on-chain data to ensure confidentiality of the data stored on blockchain. Users first encrypt the data item using the secret key and then store it on blockchain. The blockchain participants who have the secret key are allowed to access the transaction and decrypt the information.
"The hash integrity service focuses on how to use blockchain to ensure the integrity of large amounts of data. Hashing is applied to guarantee the integrity of arbitrarily large datasets which may not fit directly on the blockchain. The service
stores the hash of the raw data on blockchain to achieve data integrity of the raw data for the participants of the blockchain network that lack trust for each other. The integrity of the raw data can be checked using the on-chain hash value."
The multiple authorities service focuses on activities in blockchain-based applications (i.e. transactions) that need to be authorised by multiple blockchain addresses. Users can predefine a group of blockchain addresses which can authorise a transaction (i.e. calling a function in the smart contract) and set the minimal number of authorisations for transaction approval.
In blockchain applications, some activities need to be approved by one or more participants who are unknown when a first transaction is submitted to blockchain. The authority who can authorise to a given activity is unknown when the correspond- ing smart contract is deployed, or the corresponding trans- action is submitted to the blockchain. The dynamic binding service supports dynamic association with an address of a participant which is not defined in the respective transaction or smart contract.
"All the smart contracts running on blockchain can be accessed and called by all the participants and other smart contracts by default. A smart contract by default has no owner, which means that the author of the smart contract has no special
privilege on the smart contract once the smart contract is deployed."
When performing a function in a SC: first, check all the preconditions, then apply the effects to the contract's state, and finally interact with other contracts. Never alter this sequence.
Proxy patterns are a set of SCs working together to facilitate upgrading of SCs, despite their intrinsic immutability. A Proxy is used to refer to another SC, whose address can be changed. This approach also ensures that blockchain resources are used sparingly, thus saving GAS.
Restrict the execution of critical methods to specific users. This is accomplished using mappings of addresses, and is typically checked using modifiers.
Specify the contract owner, which is responsible for contract management and has special permissions, e.g. it is the only address authorized to call critical methods. This patter can be seen as a special instance of the authorization pattern.
An oracle is a SC providing data from outside the blockchain, which are in turn fed to the oracle by a trusted source. Here the security risk lies in how actually the source can be trusted.
A reverse oracle is a SC providing data to be read by off-chain components for checking specific conditions.
Regulate how often a task can be executed within a period of time, to limit the number of messages sent to a SC, and thus its computational load.
Limit the maximum amount of funds held within a SC.
Ensure that all requirements on a SC state and on function inputs are met.
A time constraint specifies when an action is permitted, depending on the time registered in the block holding the transaction. It could be also used in Speed Bump and Rate Limit patterns.
Used when the life of a SC has come to an end. This can be done by inserting ad-hoc code in the contract, or calling the selfdestruct function. Usually, only the contract owner is authorized to terminate a contract.
A logic which computes some critical operations, protecting from overflows, underflows or other undesired characteristics of finite arithmetic.
Encrypt on-chain critical data improving confidentiality and meeting legal requirements, such as the European GDPR.
Use contract libraries and templates as a factory for creating multiple instances.
A mutex is a mechanism to restrict concurrent access to a resource. Utilize it to hinder an external call from re-entering its caller function again.
Slow down contract sensitive tasks, so when malicious actions occur, the damage is limited and more time to counteract is available. For instance, limit the amount of money a user can withdraw per day, or impose a delay before withdrawals.
When a state change must trigger a computation in a different object, implement a messaging infrastructure where the contracts that produce messages (called publishers) can generate messages and the other contracts (called subscribers) receive them. The pattern, also known as Observer, reduces the overhead of constant information filtering.
Use tokens for transferring digital or physical services. Use standards, such as ERC20 and ERC721.
In order to ensure that a transaction is confirmed (i.e. there is a low probability that a fork happens), wait for new blocks to be added to the blockchain. The amount of blocks depends on the adopted blockchain.
Often a smart contract needs to interact with other contracts which can be updated over time. A contract registry maps each smart contract to the address of its latest version. Accordingly, when invoking a smart contract, the correct address should be retrieved from the registry.
Contract data and logic should be stored into separate contracts. In this way, when the logic need to be updated (by using a new smart contract), there is no need to migrate old data.
Sometimes, systems need to work with groups of related contracts, for instance with contracts which represent various level user account. In order to keep the system independent from the different contracts, define an abstract contract for creating all the related contracts.
The Abstract Factory pattern can facilitate this scenario because its "factory" object (the factory itself is a contract instance) is then responsible for providing creation services of concrete departmental contracts for the entire health organization. Each factory object can create contracts for a group of departments or subdivisions that are related or always interact, and it is easy to instantiate another factory object when new interactions take place.
"In order to achieve blockchain’s transparency and immutability properties, all of the data and
transaction records are maintained in the blockchain by replicating and distributing to every node in the network. It is important to limit the amount of data stored in the blockchain to avoid high cost of data storage and unattended data when it is no longer needed."
"The Proxy pattern is a well-known software pattern that can be applied to blockchain-based data storage to
resolve the tension created by the public and immutable aspects of the blockchain. Using the proxy pattern with a blockchain, a proxy contract is created to provide some lightweight representation or placeholder for the data with more intensive computation (such as acquiring data from off-blockchain storage via an Oracle. The proxy contract can expose some simpler metadata of a patient and later refer to the heavyweight implementation on demand to obtain the real data object. Each read request and modification operation of the data store can be logged in an audit trail that is transparent to the entire blockchain network for verification against data corruption. When the proxified contract (with heavyweight implementation) is updated with new storage option, for instance, interface to the proxy contract can remain the same, encapsulating detailed implementation variations."
The Publisher-Subscriber pattern can assist in broadcasting the information only to care providers that subscribe to events relating to this patient. It solves the issue of constant information filtering by actively monitoring patient activities and sending notifications to the patient’s care team as the activities take place. To avoid computation overhead on the blockchain, the actual processing of patient activities data can be done off-chain by a back-end server. When receiving the events of interest, the subscribers can then pass the heavy computation tasks to the server.
Follow a recommended functional code order, in which calls to external contracts are always the last step, to reduce the attack surface of a contract being manipulated by its own externally called contracts.
Incorporate an emergency stop functionality into the contract that can be triggered by an authenticated party to disable sensitive functions.
Prolong the completion of sensitive tasks to take steps against fraudulent activities. 
Regulate how often a task can be executed within a period of time.
Utilize a mutex to hinder an external call from re-entering its caller function again. 
Limit the maximum amount of funds at risk held within a contract.
Instead of checking whether a state is final or not in a smart contract on a blockchain, the same check is performed off-chain on the client side. A client can notify a smart contract when a final state has been reached. Other clients can prove claims wrong by providing a valid state transition. Using this pattern, the computation never has to be performed on-chain
Together, the two participants specify a smart contract including a function, which applies an external state given as argument to the contract state. This function includes a signature check to ensure both participants agree with the state change. Only if valid signatures of both participants are supplied with a requested new state, the new state is applied. This contract is deployed to the blockchain and both participants optionally make a deposit. Then, the participants perform transactions purely off-chain and peer-topeer, without involving the blockchain: One participant computes a new state, wraps it in a transaction, signs it and sends it to his counterpart. The recipient then checks the new state, signs the transaction as well in case he agrees and sends it back to the sender. This transaction, signed by both parties, can now be sent to the smart contract by a participant at any point in time. After validating both signatures, the contract updates its state accordingly.
Store the data off-chain in a content-addressable storage system and store the reference in the smart contract. Clients using the smart contract can retrieve the reference and based on that retrieve the data. Then, they can verify the data’s correctness by recomputing its address from itself and comparing it to the reference stored in the smart contract.
Outsource computation to an untrusted third party and, besides the result, generate a proof of correct execution. Instead of executing the computation itself, verify the proof of correct execution on-chain.
To optimize fees, contracts should be designed in a way that minimizes the number and size of on-chain transactions. The following two techniques can be used to reduce the footprint. – Do not check conditions on-chain after a state change. Let nodes perform the condition check locally and trigger an on-chain check in case of success. – Optimize for writes, not reads. Reading from a smart contracts is a local off-chain operation and does not require an on-chain transaction. Minimize writes and store information free of redundancy. Compute derived data locally during reads.
This pattern allows DApps like DASH to delegate the responsibility for providing account creation services to an abstract "factory" object (which is a contract instance itself). A concrete factory object can then inherit methods from the abstract factory and customize them to create accounts for a specific set of related or interacting sub-entities.
Combining the FLYWEIGHT pattern with a factory object can help minimize data storage in the Blockchain. In particular, the factory can establish a registry model that stores shared data between a set of entities in a common contract, i.e., the registry, while externalizing var- ying data to be stored in entity-specific contracts. The registry can also maintain references (i.e., addresses) to entity-specific contracts and return a combined extrinsic and intrinsic (common) data set upon request. 
Combining the PROXY pattern with a secure data retrieving service, such as an oracle, can enable secure and private data exchange services. The oracle network is a third-party service that allows a smart contract to query or retrieve data sources outside the Blockchain address space and ensures that retrieved data is genuine and uncompromised. To reduce computation overhead on-chain, a proxy can be created as a lightweight representation or placeholder for the real data until its retrieval is required.
Incorporating a notification service using the PUBLISHER-SUBSCRIBER pattern can facilitate scalable information filtering. In this design, health activities are only broadcast to providers who subscribe to events relating to their patients. It alleviates the tedious filtering process of determining which care provider should be notified about what patient activities as large volumes of transactions take place.
A pull-based inbound oracle allows blockchain applications to request states from off-chain components. When a blockchain application requests an off-chain state, the pull-based inbound oracle receives this request, gathers the state from off-chain components, and sends the result back to the blockchain (via a transaction).
A push-based inbound oracle allows off-chain information to be propagated to the blockchain by monitoring off-chain state changes and forwarding them to the blockchain.
A pull-based outbound oracle allows blockchain data to be queried and filtered to make it available to the outside world. It can be called from (off-chain) components to pull (all) blockchain data and query relevant information
A push-based outbound oracle monitors the blockchain for relevant changes to subsequently trigger or perform activities outside the blockchain.
As the compiled code of a smart contract deployed on blockchain is not readable, it is tedious to deploy and manage smart contracts that have same properties but aim to diverse clients. With the help of this pattern, developers do not need to deploy the smart contracts one after another, but deploy a contract factory once, through which the required multiple instances can be instantiated.
In a blockchain-based application, the combination of services or objects is inevitable. Consequently, how to effectively control such a combination becomes a challenge to developers, especially under the condition that each service or object is represented in the form of smart contract. Compared with Contract Factory, Contract Composer focuses on the complex structure of a contract instance, as it can construct a complicated target through multiple small pieces.
Once a smart contract is deployed on blockchain, it is not allowed to modify or update the source code of that contract. Contract Decorator pattern can avoid rewriting the whole contract when there are new requirements, developers just need to encapsulate the old contracts and append the required features into a new version of the contract through this pattern, to achieve updatability and modifiability.
Managing smart contracts may be a burdensome work as there are massive contracts having similar features in a blockchain-based system. Contract Facade pattern can relieve such pressure via providing a simple interface by coping with contract addresses. Such an interface is also in the form of smart contract, for developers to call the functions of similar contracts.
In a business process, smart contracts need to interact with each other to finish a certain activity, which may result in tight coupling of the contracts. Contract Mediator pattern aims to reduce the communication complexity of smart contracts, an instance of this pattern is in the form of smart contract, which collects and encapsulates the interactions and invocations from one contract to the others, to decoupling the smart contracts.
When a smart contract is modified due to the changing requirements in industry, all the related contracts need to be informed and updated automatically. Contract Observer pattern can deal with such problem to achieve interoperability and updatability among the contracts via an observer instance. An instance of Contract Observer needs to define the objects and information involved, once there are any changes, it should notify all the objects to update information.
This pattern can help a user to achieve authorisation of a particular activity to unknown authorities, by generating a digital secret key known as the hash secret. When the authority is decided, it will then receive the hash secret and thus have the ability to finish further task.
As there are multiple authorities in a blockchain network, this pattern can provide a flexible way to achieve better cooperation. A transaction is valid only when there are enough signatures from the authorities. In addition, this pattern can also be considered as an individual safeguard mechanism as the current blockchain technology does not provide a way to recover the lost private key.